# Old Code Generator (prior to GHC 7.8)



Material below describes old code generator that was used up to GHC 7.6 and was retired in 2012. This page is not maintained and is here only for historical purposes. See [Code generator](commentary/compiler/code-gen) page for an up to date description of the current code generator.


## Storage manager representations



See [The Storage Manager](commentary/rts/storage) for the [Layout of the stack](commentary/rts/storage/stack).



The code generator needs to know the layout of heap objects, because it generates code that accesses and constructs those heap objects.  The runtime also needs to know about the layout of heap objects, because it contains the garbage collector.  How can we share the definition of storage layout such that the code generator and the runtime both have access to it, and so that we don't have to keep two independent definitions in sync?



Currently we solve the problem this way:


- C types representing heap objects are defined in the C header files, see for example [includes/rts/storage/Closures.h](/trac/ghc/browser/ghc/includes/rts/storage/Closures.h).

- A C program, [includes/mkDerivedConstants.c](/trac/ghc/browser/ghc/includes/mkDerivedConstants.c),  `#includes` the runtime headers.
  This program is built and run when you type `make` or `make boot` in `includes/`.  It is
  run twice: once to generate `includes/DerivedConstants.h`, and again to generate 
  `includes/GHCConstants.h`.

- The file `DerivedConstants.h` contains lots of `#defines` like this:

  ```wiki
  #define OFFSET_StgTSO_why_blocked 18
  ```

  which says that the offset to the why\_blocked field of an `StgTSO` is 18 bytes.  This file
  is `#included` into [includes/Cmm.h](/trac/ghc/browser/ghc/includes/Cmm.h), so these offests are available to the
  [hand-written .cmm files](commentary/rts/cmm).

- The file `GHCConstants.h` contains similar definitions:

  ```wiki
  oFFSET_StgTSO_why_blocked = 18::Int
  ```

  This time the definitions are in Haskell syntax, and this file is `#included` directly into
  [compiler/main/Constants.lhs](/trac/ghc/browser/ghc/compiler/main/Constants.lhs).  This is the way that these offsets are made
  available to GHC's code generator.

## Generated Cmm Naming Convention



See [compiler/cmm/CLabel.hs](/trac/ghc/browser/ghc/compiler/cmm/CLabel.hs)



Labels generated by the code generator are of the form `<name>_<type>`
where `<name>` is `<Module>_<name>` for external names and `<unique>` for
internal names. `<type>` is one of the following:


<table><tr><th>info</th>
<td>Info table
</td></tr>
<tr><th>srt</th>
<td>Static reference table
</td></tr>
<tr><th>srtd</th>
<td>Static reference table descriptor
</td></tr>
<tr><th>entry</th>
<td>Entry code (function, closure)
</td></tr>
<tr><th>slow</th>
<td>Slow entry code (if any)
</td></tr>
<tr><th>ret</th>
<td>Direct return address    
</td></tr>
<tr><th>vtbl</th>
<td>Vector table
</td></tr>
<tr><th>*n*\_alt</th>
<td>Case alternative (tag *n*)
</td></tr>
<tr><th>dflt</th>
<td>Default case alternative
</td></tr>
<tr><th>btm</th>
<td>Large bitmap vector
</td></tr>
<tr><th>closure</th>
<td>Static closure
</td></tr>
<tr><th>con\_entry</th>
<td>Dynamic Constructor entry code
</td></tr>
<tr><th>con\_info</th>
<td>Dynamic Constructor info table
</td></tr>
<tr><th>static\_entry</th>
<td>Static Constructor entry code
</td></tr>
<tr><th>static\_info</th>
<td>Static Constructor info table
</td></tr>
<tr><th>sel\_info</th>
<td>Selector info table
</td></tr>
<tr><th>sel\_entry</th>
<td>Selector entry code
</td></tr>
<tr><th>cc</th>
<td>Cost centre
</td></tr>
<tr><th>ccs</th>
<td>Cost centre stack
</td></tr></table>



Many of these distinctions are only for documentation reasons.  For
example, \_ret is only distinguished from \_entry to make it easy to
tell whether a code fragment is a return point or a closure/function
entry.


## Modules


### `CodeGen`



Top level, only exports `codeGen`.



Called from `HscMain` for each module that needs to be converted from Stg to Cmm.



For each such module `codeGen` does three things:


- `cgTopBinding` for the `StgBinding`
- `cgTyCon` for the `TyCon` (These are constructors not constructor calls).
- `mkModuleInit` for the module


`mkModuleInit` generates several boilerplate initialization functions
that:


- regiser the module,
- creates an Hpc table,
- setup its profiling info (`InitConstCentres`, code coverage info `initHpc`), and
- calls the initialization functions of the modules it imports.


If neither SCC profiling or HPC are used,
then the initialization code short circuits to return.



If the module has already been initialized,
the initialization function just returns.



The `Ghc.TopHandler` and `Ghc.Prim` modules get special treatment.



`cgTopBinding` is a small wrapper around `cgTopRhs`
which in turn disptaches to:


- `cgTopRhsCons` for `StgRhsCons`
  (these are bindings of constructor applications not constructors themselves) and
- `cgTopRhsClosure` for `StgRhsClosure`.


`cgTopRhsCons` and `cgTopRhsClosure` are located in `CgCon` and `CgClosure`
which are the primary modules called by `CodeGen`.


### `CgCon`



TODO


### `CgClosure`



TODO


### `CgMonad`



The monad that most of codeGen operates inside


- Reader
- State
- (could be Writer?)
- fork
- flatten

### `CgExpr`



Called by `CgClosure` and `CgCon`.



Since everything in STG is an expression, almost everything branches off from here.



This module exports only one function `cgExpr`,
which for the most part just dispatches
to other functions to handle each specific constructor in `StgExpr`.



Here are the core functions that each constructor is disptached to
(though some may have little helper functions called in addition to the core function):


<table><tr><th>`StgApp`</th>
<td>Calls to `cgTailCall` in `CgTailCall`
</td></tr>
<tr><th>`StgConApp`</th>
<td>Calls to `cgReturnDataCon` in `CgCon`
</td></tr>
<tr><th>`StgLit`</th>
<td>
Calls to `cgLit` in `CgUtil`
and `performPrimReturn` in `CgTailCall`
</td></tr>
<tr><th>`StgOpApp`</th>
<td>
Is a bit more complicated see below.
</td></tr>
<tr><th>`StgCase`</th>
<td>Calls to `cgCase` in `CgCase`
</td></tr>
<tr><th>`StgLet`</th>
<td>Calls to `cgRhs` in `CgExpr`
</td></tr>
<tr><th>`StgLetNoEscape`</th>
<td>
Calls to `cgLetNoEscapeBindings` in `CgExpr`, but with a little bit of wrapping
by `nukeDeadBindings` and `saveVolatileVarsAndRegs`.
</td></tr>
<tr><th>`StgSCC`</th>
<td>Calls to  `emitSetCCC` in `CgProf`
</td></tr>
<tr><th>`StgTick`</th>
<td>Calls to `cgTickBox` in `CgHpc`
</td></tr>
<tr><th>`StgLam`</th>
<td>
Does not have a case because it is only for `CoreToStg`'s work.
</td></tr></table>



Some of these cases call to functions defined in `cgExpr`.
This is because they need a little bit of wrapping and processing
before calling out to their main worker function.


<table><tr><th>`cgRhs`</th>
<td>

- For `StgRhsCon` calls out to `buildDynCon` in `CgCon`.
- For `StgRhsClosure` calls out to `mkRhsClosure`.
  In turn, `mkRhsClosure` calls out to `cgStdRhsClosure` for selectors and thunks,
  and calls out to `cgRhsClosure` in the default case.
  Both these are defined in `CgClosure`.

</td></tr></table>


<table><tr><th>`cgLetNoEscapeBindings`</th>
<td>

- Wraps a call to `cgLetNoEscapeRhs` with `addBindsC`
  depending on whether it is called on a recursive or a non-recursive binding.
  In turn `cgLetNoEscapeRhs` wraps `cgLetNoEscapeClosure`
  defined in `CgLetNoEscapeClosure`.

</td></tr></table>



`StgOpApp` has a number of sub-cases.


- `StgFCallOp`
- `StgPrimOp` of a TagToEnumOp
- `StgPrimOp` that is primOpOutOfLine
- `StgPrimOp` that returns Void
- `StgPrimOp` that returns a single primitive
- `StgPrimOp` that returns an unboxed tuple
- `StgPrimOp` that returns an enumeration type


(It appears that non-foreign-call, inline [PrimOps](commentary/prim-ops) are not allowed to return complex data types (e.g. a \|Maybe\|), but this fact needs to be verified.)



Each of these cases centers around one of these three core calls:


- `emitForeignCall` in `CgForeignCall`
- `tailCallPrimOp` in `CgTailCall`
- `cgPrimOp` in `CgPrimOp`


There is also a little bit of argument and return marshelling with the following functions


<table><tr><th>Argument marshelling</th>
<td>
`shimForeignCallArg`, `getArgAmods`
</td></tr>
<tr><th>Return marshelling</th>
<td>
`dataReturnConvPrim`, `primRepToCgRep`, `newUnboxedTupleRegs`
</td></tr>
<tr><th>Performing the return</th>
<td>
`emitReturnInstr`, `performReturn`,
`returnUnboxedTuple`, `ccallReturnUnboxedTuple`
</td></tr></table>



In summary the modules that get called in order to handle a specific expression case are:


#### Also called for top level bindings by `CodeGen`


<table><tr><th>`CgCon`</th>
<td>for `StgConApp` and the `StgRhsCon` part of `StgLet`
</td></tr>
<tr><th>`CgClosure`</th>
<td>for the `StgRhsClosure` part of `StgLet`
</td></tr></table>


#### Core code generation


<table><tr><th>`CgTailCall`</th>
<td>for `StgApp`, `StgLit`, and `StgOpApp`
</td></tr>
<tr><th>`CgPrimOp`</th>
<td>for `StgOpApp`
</td></tr>
<tr><th>`CgLetNoEscapeClosure`</th>
<td>for `StgLetNoEscape`
</td></tr>
<tr><th>`CgCase`</th>
<td>for `StgCase`
</td></tr></table>


#### Profiling and Code coverage related


<table><tr><th>`CgProf`</th>
<td>for `StgSCC`
</td></tr>
<tr><th>`CgHpc`</th>
<td>for `StgTick`
</td></tr></table>


#### Utility modules that happen to have the functions for code generation


<table><tr><th>`CgForeignCall`</th>
<td>for `StgOpApp`
</td></tr>
<tr><th>`CgUtil`</th>
<td>for `cgLit`
</td></tr></table>



Note that the first two are
the same modules that are called for top level bindings by `CodeGen`,
and the last two are really utility modules,
but they happen to have the functions
needed for those code generation cases.


### Memory and Register Management


<table><tr><th>`CgBindery`</th>
<td>
Module for `CgBindings` which maps variable names
to all the volitile or stable locations where they are stored
(e.g. register, stack slot, computed from other expressions, etc.)
Provides the `addBindC`, `modifyBindC` and `getCgIdInfo` functions
for adding, modifying and looking up bindings.
</td></tr></table>


<table><tr><th>`CgStackery`</th>
<td>
Mostly utility functions for allocating and freeing stack slots.
But also has things on setting up update frames.
</td></tr></table>


<table><tr><th>`CgHeapery`</th>
<td>
Functions for allocating objects that appear on the heap such as closures and constructors.
Also includes code for stack and heap checks and `emitSetDynHdr`.
</td></tr></table>


### Function Calls and Parameter Passing



(Note: these will largely go away once CPS conversion is fully implemented.)


<table><tr><th>`CgPrimOp`, `CgTailCall`, `CgForeignCall`</th>
<td>
Handle different types of calls.
</td></tr>
<tr><th>`CgCallConv`</th>
<td>
Use by the others in this category to determine liveness and
to select in what registers and stack locations arguments and return
values get stored.
</td></tr></table>


### Misc utilities


<table><tr><th>`Bitmap`</th>
<td>
Utility functions for making bitmaps (e.g. `mkBitmap` with type `[Bool] -> Bitmap`)
</td></tr>
<tr><th>`ClosureInfo`</th>
<td>
Stores info about closures and bindings.
Includes information about memory layout, how to call a binding (`LambdaFormInfo`)
and information used to build the info table (`ClosureInfo`).
</td></tr>
<tr><th>`SMRep`</th>
<td>
Storage manager representation of closures.
Part of ClosureInfo but kept separate to "keep nhc happy."
</td></tr>
<tr><th>`CgUtils`</th>
<td>TODO
</td></tr>
<tr><th>`CgInfoTbls`</th>
<td>TODO
</td></tr></table>


### Special runtime support


<table><tr><th>`CgTicky`</th>
<td>Ticky-ticky profiling
</td></tr>
<tr><th>`CgProf`</th>
<td>Cost-centre profiling
</td></tr>
<tr><th>`CgHpc`</th>
<td>Support for the Haskell Program Coverage (hpc) toolkit, inside GHC.
</td></tr>
<tr><th>`CgParallel`</th>
<td>
Code generation for GranSim (GRAN) and parallel (PAR).
All the functions are dead stubs except `granYield` and `granFetchAndReschedule`.
</td></tr></table>


